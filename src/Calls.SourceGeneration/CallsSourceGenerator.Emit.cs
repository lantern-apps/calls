using System.Linq;
using System.Text;
using System.Threading;

namespace Calls.SourceGeneration;

public partial class CallsSourceGenerator
{
    private static string Emit(Calls meta, CancellationToken cancellationToken)
    {
        IndentStringBuilder builder = new();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        if (meta.Namespace != null)
        {
            builder.AppendLine($"namespace {meta.Namespace}");
            builder.AppendLine("{");
            builder.IncreaseIndent();
        }

        cancellationToken.ThrowIfCancellationRequested();

        builder.AppendLine($"partial class {meta.Name}");

        builder.AppendBlock(() =>
        {
            if (meta.Methods.Length > 0)
            {
                GenerateConstructor(meta, builder);
                GenerateGetRequiredServiceMethod(builder);

                GenerateInvokeCoreMethod(meta.Methods, builder);
                GenerateInvokeCoreAsyncMethod(meta.Methods, builder);

                cancellationToken.ThrowIfCancellationRequested();
            }
        });

        if (meta.Namespace != null)
        {
            builder.DecreaseIndent();
            builder.AppendLine("}");
        }

        return builder.ToString();
    }

    private static void GenerateConstructor(Calls meta, IndentStringBuilder builder)
    {
        builder.AppendLine("private readonly global::System.IServiceProvider _services;");

        builder.AppendLine();
        builder.AppendLine($"public {meta.Name}(global::System.IServiceProvider serviceProvider)");
        builder.AppendBlock(() =>
        {
            builder.AppendLine("_services = serviceProvider;");
            builder.AppendLine();
            for (int i = 0; i < meta.Methods.Length; i++)
            {
                MethodDescription handler = meta.Methods[i];
                string returnType = handler.ReturnType == null ? "null" : $"typeof({handler.ReturnType})";
                string parameters = BuildParametersParameter(handler);

                builder.AppendLine($"AddMethod(new MethodDescription({i}, {ToScriptString(handler.RoutingKey)}, {ToScriptString(handler.Awaitable)}, {returnType}, {parameters}));");
            }
        });
        builder.AppendLine();

        static string BuildParametersParameter(MethodDescription handler)
        {
            StringBuilder sb = new();
            sb.Append("new ParameterDescription[]{ ");
            for (int i = 0; i < handler.Parameters.Length; i++)
            {
                var parameter = handler.Parameters[i];
                sb.Append($"new ParameterDescription(typeof({parameter.Type}), {ToScriptString(parameter.Nullable)}, {ToScriptString(parameter.HasDefaultValue)}, {parameter.DefaultValue})");
                if (i < handler.Parameters.Length - 1)
                    sb.Append(", ");
            }

            sb.Append(" }");
            return sb.ToString();
        }

    }

    private static void GenerateGetRequiredServiceMethod(IndentStringBuilder builder)
    {
        builder.AppendLine("[global::System.Diagnostics.DebuggerHidden]");
        builder.AppendLine("private T GetRequiredService<T>()");
        builder.AppendBlock(() =>
        {
            builder.AppendLine("var service = _services.GetService(typeof(T));");
            builder.AppendLine("if (service == null)");
            builder.AppendBlock(() =>
            {
                builder.AppendLine("throw new global::System.InvalidOperationException($\"No service for type '{typeof(T)}' has been registered.\");");
            });
            builder.AppendLine("return (T)service;");
        });
        builder.AppendLine();
    }

    private static void GenerateInvokeCoreMethod(MethodDescription[] methods, IndentStringBuilder builder)
    {
        if (!methods.Any(x => !x.Awaitable))
            return;

        builder.AppendLine("[global::System.Diagnostics.DebuggerHidden]");
        builder.AppendLine($"protected override object? InvokeCore(MethodDescription method, object?[] arguments)");
        builder.AppendBlock(() =>
        {
            builder.AppendLine("int id = method.Id;");
            builder.AppendLine();

            bool first = true;
            for (int i = 0; i < methods.Length; i++)
            {
                var method = methods[i];

                if (method.Awaitable)
                    continue;

                if (first)
                {
                    builder.AppendLine($"if (id == {i})");
                    first = false;
                }
                else
                    builder.AppendLine($"else if (id == {i})");

                builder.AppendBlock(() =>
                {
                    if (method.ReturnType == null)
                    {
                        builder.AppendLine($"GetRequiredService<{method.Type}>().{method.MethodName}({BuildMethodArguments(method)});");
                        builder.AppendLine("return null;");
                    }
                    else
                    {
                        builder.AppendLine($"return GetRequiredService<{method.Type}>().{method.MethodName}({BuildMethodArguments(method)});");
                    }
                });
            }

            builder.AppendBlock("else", () =>
            {
                builder.AppendLine("return base.InvokeCore(method, arguments);");
            });
        });
        builder.AppendLine();
    }

    private static void GenerateInvokeCoreAsyncMethod(MethodDescription[] methods, IndentStringBuilder builder)
    {
        if (!methods.Any(x => x.Awaitable))
            return;

        builder.AppendLine("[global::System.Diagnostics.DebuggerHidden]");
        builder.AppendLine($"protected override async global::System.Threading.Tasks.Task<object?> InvokeCoreAsync(MethodDescription method, object?[] arguments)");
        builder.AppendBlock(() =>
        {
            builder.AppendLine("int id = method.Id;");
            builder.AppendLine();

            bool first = true;
            for (int i = 0; i < methods.Length; i++)
            {
                var method = methods[i];

                if (!method.Awaitable)
                    continue;

                if (first)
                {
                    builder.AppendLine($"if (id == {i})");
                    first = false;
                }
                else
                    builder.AppendLine($"else if (id == {i})");

                builder.AppendBlock(() =>
                {
                    if (method.ReturnType == null)
                    {
                        builder.AppendLine($"await GetRequiredService<{method.Type}>().{method.MethodName}({BuildMethodArguments(method)});");
                        builder.AppendLine("return null;");
                    }
                    else
                    {
                        builder.AppendLine($"return await GetRequiredService<{method.Type}>().{method.MethodName}({BuildMethodArguments(method)});");
                    }
                });
            }

            builder.AppendBlock("else", () =>
            {
                builder.AppendLine("return await base.InvokeCoreAsync(method, arguments);");
            });
        });
        builder.AppendLine();
    }

    private static string ToScriptString(object? value)
    {
        if (value == null) return "null";
        if (value is bool b) return b ? "true" : "false";
        if (value is string s) return $"\"{s}\"";
        if (value is char c) return $"'{c}'";
        return value.ToString();
    }

    private static string BuildMethodArguments(MethodDescription method)
    {
        StringBuilder sb = new();
        for (int i = 0; i < method.Parameters.Length; i++)
        {
            ParameterDescription? parameter = method.Parameters[i];
            if (parameter.Type == ObjectTypeCompilableName)
                sb.Append($"arguments[{i}]");
            else
                sb.Append($"({parameter.Type})arguments[{i}]");

            if (i < method.Parameters.Length - 1)
                sb.Append(", ");
        }
        return sb.ToString();
    }
}
